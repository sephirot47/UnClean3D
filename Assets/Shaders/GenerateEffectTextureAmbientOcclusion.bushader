#vertex

uniform mat4 SceneModelMatrix;

layout(location = 0) in vec3 vinTexturePosition;
layout(location = 1) in vec3 vinPosition;
layout(location = 2) in vec3 vinNormal;

out vec3 inWorldPosition;
out vec3 inWorldNormal;

void main()
{
    inWorldPosition = (SceneModelMatrix * vec4(vinPosition, 1)).xyz;
    inWorldNormal = (SceneModelMatrix * vec4(vinNormal, 0)).xyz;
    gl_Position = vec4(vinTexturePosition, 1);
}

// ===============================================================

#fragment
#define BANG_FRAGMENT

uniform mat4 SceneModelMatrix;
uniform int NumTriangles;
uniform sampler2D TrianglePositions;

in vec3 inWorldPosition;
in vec3 inWorldNormal;

layout(location = 0) out vec4 OutColor;

bool IntersectRayTriangle(vec3 rayOrig,
                          vec3 rayDir,
                          vec3 triP0,
                          vec3 triP1,
                          vec3 triP2,
                          float maxDist)
{
    vec3 v10 = (triP1 - triP0);
    vec3 v20 = (triP2 - triP0);

    vec3 h = cross(rayDir, v20);
    float a = dot(v10, h);

    float Epsilon = 1e-8;
    if (a > -Epsilon && a < Epsilon) { return false; }

    float f = 1.0 / a;
    vec3 s = (rayOrig - triP0);
    float u = f * dot(s, h);

    if (u < 0.0 || u > 1.0)
    {
        return false;
    }

    vec3 q = cross(s, v10);
    float v = f * dot(rayDir, q);

    if (v < 0.0 || u + v > 1.0) { return false; }

    float t = (f * dot(v20, q));
    if (t > maxDist || t < Epsilon) { return false; }

    return true;
}

float dot2( in vec3 v ) { return dot(v,v); }

float udTriangle( in vec3 v1, in vec3 v2, in vec3 v3, in vec3 p )
{
    // prepare data
    vec3 v21 = v2 - v1; vec3 p1 = p - v1;
    vec3 v32 = v3 - v2; vec3 p2 = p - v2;
    vec3 v13 = v1 - v3; vec3 p3 = p - v3;
    vec3 nor = cross( v21, v13 );

    return sqrt( // inside/outside test
                 (sign(dot(cross(v21,nor),p1)) +
                  sign(dot(cross(v32,nor),p2)) +
                  sign(dot(cross(v13,nor),p3))<2.0)
                  ?
                  // 3 edges
                  min( min(
                  dot2(v21*clamp(dot(v21,p1)/dot2(v21),0.0,1.0)-p1),
                  dot2(v32*clamp(dot(v32,p2)/dot2(v32),0.0,1.0)-p2) ),
                  dot2(v13*clamp(dot(v13,p3)/dot2(v13),0.0,1.0)-p3) )
                  :
                  // 1 face
                  dot(nor,p1)*dot(nor,p1)/dot2(nor) );
}

vec4 GetTriangleData(int triId,
                     int vertexId,
                     ivec2 textureSize,
                     vec2 texelSize,
                     sampler2D Texture)
{
    int coord = triId * 3 + vertexId;
    ivec2 texelPos = ivec2(coord % textureSize.x,
                           coord / textureSize.x);
    vec2 uvs = texelPos * texelSize;
    uvs += texelSize * 0.5f;
    return texture(Texture, uvs).xyzw;
}

void GetTriangle(int triId,
                 ivec2 posTextureSize,
                 vec2 posTexelSize,
                 inout vec3 triPoints[3])
{
    for (int i = 0; i < 3; ++i)
    {
        triPoints[i] = GetTriangleData(triId, i,
                                       posTextureSize, posTexelSize,
                                       TrianglePositions).xyz;
    }
}

float rand(vec3 co)
{
    return fract(sin(dot(co.xyz, vec3(12.9898, 78.233, 32.123))) * 43758.5453);
}
vec3 rand3(vec3 co)
{
    return vec3(rand(co.xyz), rand(co.yxz), rand(co.zyx));
}

void main()
{
    vec3 worldPosition = inWorldPosition;
    vec3 worldNormal = normalize(inWorldNormal);

    ivec2 posTextureSize = textureSize(TrianglePositions, 0);
    vec2 posTexelSize = (1.0 / posTextureSize);

    float totalRays = 8;
    float intersectedRays = 0;
    for (int iRay = 0; iRay < totalRays; ++iRay)
    {
        for (int triId = 0; triId < NumTriangles; ++triId)
        {
            vec3 triPoints[3];
            GetTriangle(triId, posTextureSize, posTexelSize, triPoints);

            // vec3 triNormal = normalize(cross(normalize(triPoints[1] - triPoints[0]),
            //                                  normalize(triPoints[2] - triPoints[0])));
            vec3 rayOrigin = worldPosition + worldNormal * 0.0001f;
            vec3 rayDirection = rand3(worldPosition * (iRay + 100));
            rayDirection = rayDirection * 2 - 1;
            rayDirection = normalize(rayDirection);
            if (dot(rayDirection, worldNormal) < 0)
            {
                rayDirection *= -1;
            }

            // if (abs(udTriangle(triPoints[0], triPoints[1], triPoints[2], worldPosition)) <= 0.0001)
            // {
            //     OutColor = vec4(triNormal, 1);
            //     return;
            // }

            // OutColor = vec4(vec3(rayDirection), 1);
            // return;

            if (IntersectRayTriangle(rayOrigin, rayDirection,
                                     triPoints[0], triPoints[1], triPoints[2],
                                     0.01))
            {
                ++intersectedRays;
                break;
            }
        }
    }

    float ambientOcclusion = 1.0f - (intersectedRays / totalRays);
    OutColor = vec4(vec3(ambientOcclusion), 1);
}


