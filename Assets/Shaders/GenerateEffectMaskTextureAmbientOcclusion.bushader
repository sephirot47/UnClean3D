#vertex

uniform mat4 SceneModelMatrix;

layout(location = 0) in vec3 vinTexturePosition;
layout(location = 1) in vec3 vinPosition;
layout(location = 2) in vec3 vinNormal;

out vec3 inWorldPosition;
flat out int inTriId;

void main()
{
    inWorldPosition = (SceneModelMatrix * vec4(vinPosition, 1)).xyz;
    inTriId = gl_VertexID / 3;
    gl_Position = vec4(vinTexturePosition, 1);
}

// ===============================================================

#fragment
#define BANG_FRAGMENT

#include "RayCast.glsl"

in vec3 inWorldPosition;
flat in int inTriId;

layout(location = 0) out vec4 OutColor;

vec3[3] GetTrianglePoints(int triId)
{
    vec3 triPoints[3];
    for (int vi = 0; vi < 3; ++vi)
    {
        triPoints[vi] = GetTrianglePositionsElement(triId, vi).xyz;
    }
    return triPoints;
}

void main()
{
    vec3 worldPosition = inWorldPosition;
    int triId = inTriId;

    vec3[3] triWorldPosition = GetTrianglePoints(triId);
    vec3 worldNormal = normalize( cross(triWorldPosition[1] - triWorldPosition[0],
                                        triWorldPosition[2] - triWorldPosition[0]) );
    // OutColor = vec4(worldNormal, 1); return;

    float totalRays = 5;
    float maxDistance = 4.0f;
    float intersectedRaysAO = 0;
    for (int iRay = 0; iRay < totalRays; ++iRay)
    {
        vec3 rayDirection = rand3(worldPosition * (iRay + 100));
        // OutColor = vec4(vec3(rayDirection.x),1);
        // return;
        rayDirection = normalize(rayDirection * 2 - 1);
        rayDirection *= sign(dot(rayDirection, worldNormal));
        // rayDirection.x = abs(rayDirection.x);
        // rayDirection.y = abs(rayDirection.y);
        // rayDirection.z = -abs(rayDirection.z);
        // rayDirection = normalize(vec3(1,-1,0));
        // OutColor = vec4(vec3(rayDirection), 1); return;

        vec3 rayOrigin = worldPosition + worldNormal * 0.00001f;

        int triId;
        float hitDistance;
        vec3 triBaryCoords;
        if (RayCast(rayOrigin, rayDirection,
                    maxDistance, hitDistance,
                    triId, triBaryCoords))
        {
            float distFactor = 0.0f; // (hitDistance / maxDistance);
            intersectedRaysAO += (1.0f - distFactor);
        }
    }

    float ambientOcclusion = (intersectedRaysAO / totalRays);
    OutColor = vec4(vec3(ambientOcclusion), 1);
}


