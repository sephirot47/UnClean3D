#vertex

uniform mat4 SceneModelMatrix;

layout(location = 0) in vec3 vinTexturePosition;
layout(location = 1) in vec3 vinPosition;
layout(location = 2) in vec3 vinNormal;

out vec3 inWorldPosition;
out vec3 inWorldNormal;

void main()
{
    inWorldPosition = (SceneModelMatrix * vec4(vinPosition, 1)).xyz;
    inWorldNormal = (SceneModelMatrix * vec4(vinNormal, 0)).xyz;
    gl_Position = vec4(vinTexturePosition, 1);
}

// ===============================================================

#fragment
#define BANG_FRAGMENT

uniform mat4 SceneModelMatrix;
uniform int NumTriangles;
uniform sampler2D TrianglePositions;

uniform sampler2D GridTexture;
uniform int NumTrisPerCell;
uniform int NumGridCells;
uniform vec3 GridCellSize;
uniform vec3 GridMinPoint;

in vec3 inWorldPosition;
in vec3 inWorldNormal;

layout(location = 0) out vec4 OutColor;

bool IntersectRayPlane(vec3 rayOrig,
                       vec3 rayDir,
                       vec3 planePoint,
                       vec3 planeNormal,
                       out float intersectionDist)
{
    float dotProd = dot(planeNormal, rayDir);
    if (dotProd > 0.001f)
    {
        intersectionDist = dot(planePoint - rayOrig, planeNormal) / dotProd;
        return intersectionDist >= 0.0f;
    }
    return false;
}

bool IntersectRayTriangle(vec3 rayOrig,
                          vec3 rayDir,
                          vec3 triP0,
                          vec3 triP1,
                          vec3 triP2,
                          float maxDist)
{
    vec3 v10 = (triP1 - triP0);
    vec3 v20 = (triP2 - triP0);

    vec3 h = cross(rayDir, v20);
    float a = dot(v10, h);

    float Epsilon = 1e-8;
    if (a > -Epsilon && a < Epsilon) { return false; }

    float f = 1.0 / a;
    vec3 s = (rayOrig - triP0);
    float u = f * dot(s, h);
    if (u < 0.0 || u > 1.0) { return false; }

    vec3 q = cross(s, v10);
    float v = f * dot(rayDir, q);
    if (v < 0.0 || u + v > 1.0) { return false; }

    float t = (f * dot(v20, q));
    if (t > maxDist || t < Epsilon) { return false; }

    return true;
}

float rand(vec3 co)
{
    return fract(sin(dot(co.xyz, vec3(12.9898, 78.233, 32.123))) * 43758.5453);
}
vec3 rand3(vec3 co)
{
    return vec3(rand(co.xyz), rand(co.yxz), rand(co.zyx));
}

void main()
{
    vec3 worldPosition = inWorldPosition;
    vec3 worldNormal = normalize(inWorldNormal);

    ivec2 posTextureSize = textureSize(TrianglePositions, 0);
    vec2 posTexelSize = (1.0 / posTextureSize);

    ivec2 gridTextureSize = textureSize(GridTexture, 0);
    vec2 gridTexelSize = (1.0 / gridTextureSize);

    float totalRays = 100;
    float intersectedRays = 0;
    for (int iRay = 0; iRay < totalRays; ++iRay)
    {
        bool foundIntersection = false;

        vec3 rayDirection = rand3(worldPosition * (iRay + 100));
        vec3 rayOrigin = worldPosition + worldNormal * 0.0001f;
        rayDirection = rayDirection * 2 - 1;
        rayDirection = normalize(rayDirection);
        rayDirection *= sign(dot(rayDirection, worldNormal));

        vec3 gridWorldPos = (rayOrigin.xyz - GridMinPoint.xyz);
        ivec3 gridCoordXYZ = ivec3(floor(gridWorldPos.xyz / GridCellSize.xyz));
        int originCellCoord = int(NumGridCells * NumGridCells * gridCoordXYZ.z +
                                  NumGridCells * gridCoordXYZ.y +
                                  gridCoordXYZ.x);
        originCellCoord *= NumTrisPerCell;

        for (int i = 0; i < NumTrisPerCell; ++i)
        {
            int cellTriCoord = originCellCoord + i;
            vec2 cellTriTexCoord = vec2(cellTriCoord % gridTextureSize.x,
                                        cellTriCoord / gridTextureSize.x);
            vec2 cellTriUvs = cellTriTexCoord * gridTexelSize;

            vec4 gridTextureColor = texture(GridTexture, cellTriUvs);
            if (gridTextureColor.a >= 0.5)
            {
                int triId = int(255 * 255 * 255 * gridTextureColor.r +
                                255 * 255 * gridTextureColor.g +
                                255 * gridTextureColor.b);
            // for (int triId = 0; triId < NumTriangles; ++triId)
            {
                    vec3 triPoints[3];
                    for (int i = 0; i < 3; ++i)
                    {
                        int triCoord = triId * 3 + i;
                        ivec2 triTexCoord = ivec2(triCoord % posTextureSize.x,
                                                  triCoord / posTextureSize.x);
                        vec2 triTexUvs = triTexCoord * posTexelSize;
                        triPoints[i] = texture(TrianglePositions, triTexUvs, 0).xyz;
                    }

                    if (IntersectRayTriangle(rayOrigin, rayDirection,
                                             triPoints[0], triPoints[1], triPoints[2],
                                             0.05))
                    {
                        ++intersectedRays;
                        foundIntersection = true;
                        break;
                    }
                }
            }
        }
    }

    float ambientOcclusion = (intersectedRays / totalRays);
    OutColor = vec4(vec3(ambientOcclusion), 1);
}


