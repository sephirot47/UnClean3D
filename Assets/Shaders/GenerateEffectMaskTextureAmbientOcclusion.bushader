#vertex

uniform mat4 SceneModelMatrix;

layout(location = 0) in vec3 vinTexturePosition;
layout(location = 1) in vec3 vinPosition;
layout(location = 2) in vec3 vinNormal;

out vec3 inWorldPosition;
out vec3 inWorldNormal;

void main()
{
    inWorldPosition = (SceneModelMatrix * vec4(vinPosition, 1)).xyz;
    inWorldNormal = (SceneModelMatrix * vec4(vinNormal, 0)).xyz;
    gl_Position = vec4(vinTexturePosition, 1);
}

// ===============================================================

#fragment
#define BANG_FRAGMENT

#include "RayCast.glsl"

in vec3 inWorldPosition;
in vec3 inWorldNormal;

layout(location = 0) out vec4 OutColor;

float rand(vec3 co)
{
    return fract(sin(dot(co.xyz, vec3(12.9898, 78.233, 32.123))) * 43758.5453);
}
vec3 rand3(vec3 co)
{
    return vec3(rand(co.xyz), rand(co.yxz), rand(co.zyx));
}

void main()
{
    vec3 worldPosition = inWorldPosition;
    vec3 worldNormal = normalize(inWorldNormal);

    float totalRays = 10;
    float maxDistance = 0.05;
    float intersectedRaysAO = 0;
    for (int iRay = 0; iRay < totalRays; ++iRay)
    {
        vec3 rayDirection = rand3(worldPosition * (iRay + 100));
        rayDirection = normalize(rayDirection * 2 - 1);
        rayDirection *= sign(dot(rayDirection, worldNormal));

        vec3 rayOrigin = worldPosition + worldNormal * 0.001f;

        int triId;
        float hitDistance;
        vec3 triBaryCoords;
        if (RayCast(rayOrigin, rayDirection, maxDistance, hitDistance, triId, triBaryCoords))
        {
            float distFactor = (hitDistance / maxDistance);
            intersectedRaysAO += (1.0f - distFactor);
        }
    }

    float ambientOcclusion = (intersectedRaysAO / totalRays);
    OutColor = vec4(vec3(ambientOcclusion), 1);
}


