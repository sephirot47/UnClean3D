#vertex

uniform mat4 SceneModelMatrix;

layout(location = 0) in vec3 vinTexturePosition;
layout(location = 1) in vec3 vinPosition;
layout(location = 3) in vec2 vinUvs;

out vec3 inWorldPosition;
out vec2 inUv;
flat out int inTriId;

void main()
{
    inWorldPosition = (SceneModelMatrix * vec4(vinPosition, 1)).xyz;
    inUv = vinTexturePosition.xy * 0.5 + 0.5;
    inTriId = gl_VertexID / 3;
    gl_Position = vec4(vinTexturePosition, 1);
}

// ===============================================================

#fragment
#define BANG_FRAGMENT

#include "ArrayOfArrays.glsl"

ARRAY_OF_ARRAYS(TriangleUvs)
ARRAY_OF_ARRAYS(TrianglePositions)
ARRAY_OF_ARRAYS(OneRingNeighborhoods)

uniform sampler2D TextureToBlur;

float side(vec2 p1, vec2 p2, vec2 p3)
{
    return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);
}

vec3 GetProjectedPoint(vec3 point, vec3 planePoint, vec3 planeNormal)
{
    float dist = dot(point - planePoint, planeNormal);
    return point - (planeNormal * dist);
}

float GetTriangleArea(vec2 p0, vec2 p1, vec2 p2)
{
    return abs(p0.x * (p1.y - p2.y) + p1.x * (p2.y - p0.y) + p2.x * (p0.y - p1.y)) * 0.5f;
}
float GetTriangleArea(vec3 p0, vec3 p1, vec3 p2)
{
    return length(cross((p1 - p0), (p2 - p0))) * 0.5f;
}

vec3 GetBarycentricCoordinates(vec3 point, vec3 triP0, vec3 triP1, vec3 triP2)
{
    vec3 v0 = triP1 - triP0;
    vec3 v1 = triP2 - triP0;
    vec3 triNormal = normalize(cross(v0, v1));
    vec3 projPoint = GetProjectedPoint(point, triP0, triNormal);

    vec3 v2 = projPoint - triP0;
    float d00 = dot(v0, v0);
    float d01 = dot(v0, v1);
    float d11 = dot(v1, v1);
    float d20 = dot(v2, v0);
    float d21 = dot(v2, v1);
    float denom = d00 * d11 - d01 * d01;

    vec3 baryCoords;
    baryCoords.y = (d11 * d20 - d01 * d21) / denom;
    baryCoords.z = (d00 * d21 - d01 * d20) / denom;
    baryCoords.x = 1.0f - baryCoords.y - baryCoords.z;
    return baryCoords;
}

vec3 GetBarycentricCoordinates(vec2 point, vec2 triP0, vec2 triP1, vec2 triP2)
{
    vec2 v0 = triP1 - triP0;
    vec2 v1 = triP2 - triP0;

    vec2 v2 = point - triP0;
    float d00 = dot(v0, v0);
    float d01 = dot(v0, v1);
    float d11 = dot(v1, v1);
    float d20 = dot(v2, v0);
    float d21 = dot(v2, v1);
    float denom = d00 * d11 - d01 * d01;

    vec3 baryCoords;
    baryCoords.y = (d11 * d20 - d01 * d21) / denom;
    baryCoords.z = (d00 * d21 - d01 * d20) / denom;
    baryCoords.x = 1.0f - baryCoords.y - baryCoords.z;
    return baryCoords;
}

bool PointInTriangle(vec2 point, vec2 triP0, vec2 triP1, vec2 triP2)
{
    float d1 = side(point, triP0, triP1);
    float d2 = side(point, triP1, triP2);
    float d3 = side(point, triP2, triP0);
    bool anyLeft  = (d1 < 0) || (d2 < 0) || (d3 < 0);
    bool anyRight = (d1 > 0) || (d2 > 0) || (d3 > 0);
    return !(anyLeft && anyRight);
}

float IntersectRayPlaneDist(vec3 rayOrig, vec3 rayDir, vec3 planePoint, vec3 planeNormal)
{
    float dotProd = dot(planeNormal, rayDir);
    return dot(planePoint - rayOrig, planeNormal) / dotProd;
}

vec3[3] GetTrianglePoints(int triId)
{
    vec3 triPoints[3];
    for (int vi = 0; vi < 3; ++vi)
    {
        triPoints[vi] = GetTrianglePositionsElement(triId, vi).xyz;
    }
    return triPoints;
}

in vec3 inWorldPosition;
in vec2 inUv;
flat in int inTriId;

layout(location = 0) out vec4 OutColor;

void main()
{
    vec3 thisWorldPosition = inWorldPosition;
    int thisTriId = inTriId;
    vec2 thisUv = inUv;

    vec3[3] thisTriWorldPosition = GetTrianglePoints(thisTriId);
    vec3 thisTriXVector = normalize(thisTriWorldPosition[1] - thisTriWorldPosition[0]);
    vec3 thisTriNormal = normalize(
                cross(thisTriXVector, thisTriWorldPosition[2] - thisTriWorldPosition[0]));
    vec3 thisTriYVector = cross(thisTriXVector, thisTriNormal);

    vec2 texelSize = (1.0f / textureSize(TextureToBlur, 0).xy);

    int BlurRadius = 5;
    float BlurStepSize = 0.02f;
    vec4 accumulatedColor = vec4(0);
    bool allSamplesInside = true;
    int numNeighbors = GetOneRingNeighborhoodsArraySize(thisTriId);
    for (int y = -BlurRadius; y <= BlurRadius; ++y)
    {
        for (int x = -BlurRadius; x <= BlurRadius; ++x)
        {
            vec2 sampleXYOffset = vec2(x,y) * BlurStepSize;
            vec3 sampleWorldOffset = thisTriXVector * sampleXYOffset.x +
                                     thisTriYVector * sampleXYOffset.y;
            vec3 sampleWorldPosition = thisWorldPosition + sampleWorldOffset;

            vec4 sampleColor;
            {
                for (int i = 0; i < numNeighbors+1; ++i) // Neighbors or this triId
                {
                    int neighborTriId = (i == 0 ? thisTriId :
                          int(GetOneRingNeighborhoodsElement(thisTriId, i-1).x));

                    vec3[3] nTriWorldPosition = GetTrianglePoints(neighborTriId);
                    vec3 sampleBarycentricCoordsInNTri =
                       GetBarycentricCoordinates(sampleWorldPosition, nTriWorldPosition[0],
                                                 nTriWorldPosition[1], nTriWorldPosition[2]);

                    const float Eps = 1e-5f;
                    bool isInsideNeighborTriangle =
                        (sampleBarycentricCoordsInNTri[0] >=  -Eps &&
                         sampleBarycentricCoordsInNTri[0] <= 1+Eps &&
                         sampleBarycentricCoordsInNTri[1] >=  -Eps &&
                         sampleBarycentricCoordsInNTri[1] <= 1+Eps &&
                         sampleBarycentricCoordsInNTri[2] >=  -Eps &&
                         sampleBarycentricCoordsInNTri[2] <= 1+Eps);

                    if (isInsideNeighborTriangle)
                    {
                        vec2[3] nTriUvs;
                        for (int j = 0; j < 3; ++j)
                        {
                            nTriUvs[j] = GetTriangleUvsElement(neighborTriId, j).xy;
                            nTriUvs[j].y = 1.0 - nTriUvs[j].y;
                        }

                        vec2 sampleUvsInNTri =
                             sampleBarycentricCoordsInNTri[0] * nTriUvs[0] +
                             sampleBarycentricCoordsInNTri[1] * nTriUvs[1] +
                             sampleBarycentricCoordsInNTri[2] * nTriUvs[2];

                        sampleColor = texture(TextureToBlur, sampleUvsInNTri);
                        break;
                    }
                }
            }
            accumulatedColor += sampleColor;
        }
    }

    float kernelSize = (BlurRadius * 2 + 1);
    vec4 meanColor = (accumulatedColor / (kernelSize * kernelSize));
    meanColor.a = 1.0f;
    OutColor = meanColor;
}


