#vertex

uniform mat4 SceneModelMatrix;

layout(location = 0) in vec3 vinTexturePosition;
layout(location = 1) in vec3 vinPosition;
layout(location = 3) in vec2 vinUvs;

out vec3 inWorldPosition;
out vec2 inUv;
flat out int inTriId;

void main()
{
    inWorldPosition = (SceneModelMatrix * vec4(vinPosition, 1)).xyz;
    inUv = vinTexturePosition.xy * 0.5 + 0.5;
    inTriId = gl_VertexID / 3;
    gl_Position = vec4(vinTexturePosition, 1);
}

// ===============================================================

#fragment
#define BANG_FRAGMENT

#include "ArrayOfArrays.glsl"

ARRAY_OF_ARRAYS(TriangleUvs)
ARRAY_OF_ARRAYS(TrianglePositions)
ARRAY_OF_ARRAYS(OneRingNeighborhoods)

uniform sampler2D TextureToBlur;
const float Epsilon = 1e-4f;
const float INF = 1e9f;

float side(vec2 p1, vec2 p2, vec2 p3)
{
    return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);
}

vec3 GetProjectedPoint(vec3 point, vec3 planePoint, vec3 planeNormal)
{
    float dist = dot(point - planePoint, planeNormal);
    return point - (planeNormal * dist);
}

float GetTriangleArea(vec2 p0, vec2 p1, vec2 p2)
{
    return abs(p0.x * (p1.y - p2.y) + p1.x * (p2.y - p0.y) + p2.x * (p0.y - p1.y)) * 0.5f;
}
float GetTriangleArea(vec3 p0, vec3 p1, vec3 p2)
{
    return length(cross((p1 - p0), (p2 - p0))) * 0.5f;
}

vec3 GetBarycentricCoordinates(vec3 point, vec3 triP0, vec3 triP1, vec3 triP2)
{
    vec3 v0 = triP1 - triP0;
    vec3 v1 = triP2 - triP0;
    vec3 triNormal = normalize(cross(v0, v1));
    vec3 projPoint = GetProjectedPoint(point, triP0, triNormal);

    vec3 v2 = projPoint - triP0;
    float d00 = dot(v0, v0);
    float d01 = dot(v0, v1);
    float d11 = dot(v1, v1);
    float d20 = dot(v2, v0);
    float d21 = dot(v2, v1);
    float denom = d00 * d11 - d01 * d01;

    vec3 baryCoords;
    baryCoords.y = (d11 * d20 - d01 * d21) / denom;
    baryCoords.z = (d00 * d21 - d01 * d20) / denom;
    baryCoords.x = 1.0f - baryCoords.y - baryCoords.z;
    return baryCoords;
}

vec3 GetBarycentricCoordinates(vec2 point, vec2 triP0, vec2 triP1, vec2 triP2)
{
    vec2 v0 = triP1 - triP0;
    vec2 v1 = triP2 - triP0;

    vec2 v2 = point - triP0;
    float d00 = dot(v0, v0);
    float d01 = dot(v0, v1);
    float d11 = dot(v1, v1);
    float d20 = dot(v2, v0);
    float d21 = dot(v2, v1);
    float denom = d00 * d11 - d01 * d01;

    vec3 baryCoords;
    baryCoords.y = (d11 * d20 - d01 * d21) / denom;
    baryCoords.z = (d00 * d21 - d01 * d20) / denom;
    baryCoords.x = 1.0f - baryCoords.y - baryCoords.z;
    return baryCoords;
}

bool PointInTriangle(vec2 point, vec2 triP0, vec2 triP1, vec2 triP2)
{
    float d1 = side(point, triP0, triP1);
    float d2 = side(point, triP1, triP2);
    float d3 = side(point, triP2, triP0);
    bool anyLeft  = (d1 < 0) || (d2 < 0) || (d3 < 0);
    bool anyRight = (d1 > 0) || (d2 > 0) || (d3 > 0);
    return !(anyLeft && anyRight);
}

bool PointInTriangle(vec3 baryCoords)
{
    return (baryCoords[0] >= -Epsilon && baryCoords[0] <= 1.0f + Epsilon &&
            baryCoords[1] >= -Epsilon && baryCoords[1] <= 1.0f + Epsilon &&
            baryCoords[2] >= -Epsilon && baryCoords[2] <= 1.0f + Epsilon);
}

bool PointInTriangle(vec3 point, vec3 triP0, vec3 triP1, vec3 triP2)
{
    vec3 baryCoords = GetBarycentricCoordinates(point, triP0, triP1, triP2);
    return PointInTriangle(baryCoords);
}

float IntersectRayPlaneDist(vec3 rayOrig, vec3 rayDir, vec3 planePoint, vec3 planeNormal)
{
    float dotProd = dot(planeNormal, rayDir);
    return dot(planePoint - rayOrig, planeNormal) / dotProd;
}

vec3[3] GetTrianglePoints(int triId)
{
    vec3 triPoints[3];
    for (int vi = 0; vi < 3; ++vi)
    {
        triPoints[vi] = GetTrianglePositionsElement(triId, vi).xyz;
    }
    return triPoints;
}

in vec3 inWorldPosition;
in vec2 inUv;
flat in int inTriId;

layout(location = 0) out vec4 OutColor;

void main()
{
    vec3 thisWorldPosition = inWorldPosition;
    int thisTriId = inTriId;
    vec2 thisUv = inUv;

    vec3[3] thisTriWorldPosition = GetTrianglePoints(thisTriId);
    vec3 thisTriXVector = normalize(thisTriWorldPosition[1] - thisTriWorldPosition[0]);
    vec3 thisTriNormal = normalize(
                cross(thisTriXVector, thisTriWorldPosition[2] - thisTriWorldPosition[0]));
    vec3 thisTriYVector = normalize(cross(thisTriXVector, thisTriNormal));

    vec2 texelSize = (1.0f / textureSize(TextureToBlur, 0).xy);

    vec3 thisTriEdge01 = (thisTriWorldPosition[1] - thisTriWorldPosition[0]);
    vec3 thisTriEdge12 = (thisTriWorldPosition[2] - thisTriWorldPosition[1]);
    vec3 thisTriEdge20 = (thisTriWorldPosition[0] - thisTriWorldPosition[2]);
    vec3 thisTriEdge01Norm = normalize(thisTriEdge01);
    vec3 thisTriEdge12Norm = normalize(thisTriEdge12);
    vec3 thisTriEdge20Norm = normalize(thisTriEdge20);

    // OutColor = vec4(thisWorldPosition.xyz, 1); return;

    int BlurRadius = 10;
    float BlurStepSize = 0.03f;
    vec4 accumulatedColor = vec4(0);
    float totalWeight = 0.0f;
    int numNeighbors = GetOneRingNeighborhoodsArraySize(thisTriId);
    for (int y = -BlurRadius; y <= BlurRadius; ++y)
    {
        for (int x = -BlurRadius; x <= BlurRadius; ++x)
        {
            bool insideSomeTriangle = true;
            vec2 xy = vec2(x,y);
            float xyLength = length(xy);
            if (xyLength >= BlurRadius)
            {
                continue;
            }

            vec2 sampleXYOffset = xy * BlurStepSize;
            vec3 sampleWorldOffset = thisTriXVector * sampleXYOffset.x +
                                     thisTriYVector * sampleXYOffset.y;
            vec3 sampleWorldPosition = thisWorldPosition + sampleWorldOffset;
            float weight = 1.0f; // min(1.0f / xyLength, 5.0f);

            // OutColor = vec4(sampleWorldPosition.xyz, 1); return;

            vec4 sampleColor = vec4(0);
            {
                for (int i = 0; i < (numNeighbors + 1); ++i) // Neighbors or this triId
                {
                    int neighborTriId = (i == 0 ? thisTriId :
                          int(GetOneRingNeighborhoodsElement(thisTriId, i-1).x));

                    vec3[3] nTriWorldPosition = GetTrianglePoints(neighborTriId);
                    vec3 sampleBarycentricCoordsInNTri =
                       GetBarycentricCoordinates(sampleWorldPosition,
                                                 nTriWorldPosition[0],
                                                 nTriWorldPosition[1],
                                                 nTriWorldPosition[2]);

                    bool isInsideNeighborTriangle =
                                PointInTriangle(sampleBarycentricCoordsInNTri);
                    if (isInsideNeighborTriangle)
                    {
                        // Modify sample world position so that it follows the surface
                        vec3 nTriEdge01 = (nTriWorldPosition[1] - nTriWorldPosition[0]);
                        vec3 nTriEdge02 = (nTriWorldPosition[2] - nTriWorldPosition[0]);
                        vec3 nTriNormal = normalize(cross(nTriEdge01, nTriEdge02));

                        bool isInsideNeighborTriangleAfterProjected = true;
                        if (neighborTriId != thisTriId) // && (dot(thisTriNormal, nTriNormal) < 0.9f))
                        {
                            isInsideNeighborTriangleAfterProjected = false;

                            float sampleWorldOffsetLength = length(sampleWorldOffset);
                            vec3 sampleWorldOffsetDir = (sampleWorldOffset / sampleWorldOffsetLength);

                            vec3 triNormalsMean = normalize(thisTriNormal + nTriNormal);
                            vec3 thisTriEdge01PlaneNormal = normalize( cross(thisTriEdge01Norm, triNormalsMean) ); // triNormsMean); // sampleWorldOffsetDir; // cross(sampleWorldOffsetDir, normalize(thisTriNormal + nTriNormal)); // cross(thisTriNormal, sampleWorldOffsetDir); // thisTriEdge01Norm);
                            vec3 thisTriEdge12PlaneNormal = normalize( cross(thisTriEdge12Norm, triNormalsMean) ); // triNormsMean); // sampleWorldOffsetDir; // cross(sampleWorldOffsetDir, normalize(thisTriNormal + nTriNormal)); // cross(thisTriNormal, sampleWorldOffsetDir); // thisTriEdge12Norm);
                            vec3 thisTriEdge20PlaneNormal = normalize( cross(thisTriEdge20Norm, triNormalsMean) ); // triNormsMean); // sampleWorldOffsetDir; // cross(sampleWorldOffsetDir, normalize(thisTriNormal + nTriNormal)); // cross(thisTriNormal, sampleWorldOffsetDir); // thisTriEdge20Norm);

                            // if (length(thisTriEdge01) < 0.00001f || length(thisTriEdge12) < 0.00001f || length(thisTriEdge20) < 0.00001f) { OutColor=vec4(0,1,1,1); return; }

                            vec3 intersectedEdgePlanePoint;
                            vec3 intersectedEdgePlaneNormal;
                            float minEdgePlaneIntersectionDistance = INF;

                            float distToEdgePlane01 = IntersectRayPlaneDist(thisWorldPosition, sampleWorldOffsetDir,
                                                                            thisTriWorldPosition[0], thisTriEdge01PlaneNormal);
                            float distToEdgePlane12 = IntersectRayPlaneDist(thisWorldPosition, sampleWorldOffsetDir,
                                                                            thisTriWorldPosition[1], thisTriEdge12PlaneNormal);
                            float distToEdgePlane20 = IntersectRayPlaneDist(thisWorldPosition, sampleWorldOffsetDir,
                                                                            thisTriWorldPosition[2], thisTriEdge20PlaneNormal);

                            // if (distToEdgePlane01 < 0 && distToEdgePlane12 < 0 && distToEdgePlane20 < 0) { OutColor=vec4(0,0,1,1); return; }

                            // distToEdgePlane01 = abs(distToEdgePlane01);
                            // distToEdgePlane12 = abs(distToEdgePlane12);
                            // distToEdgePlane20 = abs(distToEdgePlane20);

                            if (distToEdgePlane01 < 0) { distToEdgePlane01 = INF; }
                            if (distToEdgePlane12 < 0) { distToEdgePlane12 = INF; }
                            if (distToEdgePlane20 < 0) { distToEdgePlane20 = INF; }

                            if (distToEdgePlane01 < minEdgePlaneIntersectionDistance)
                            {
                                intersectedEdgePlanePoint = thisTriWorldPosition[0];
                                intersectedEdgePlaneNormal = thisTriEdge01PlaneNormal;
                                minEdgePlaneIntersectionDistance = distToEdgePlane01;
                            }
                            if (distToEdgePlane12 < minEdgePlaneIntersectionDistance)
                            {
                                intersectedEdgePlanePoint = thisTriWorldPosition[1];
                                intersectedEdgePlaneNormal = thisTriEdge12PlaneNormal;
                                minEdgePlaneIntersectionDistance = distToEdgePlane12;
                            }
                            if (distToEdgePlane20 < minEdgePlaneIntersectionDistance)
                            {
                                intersectedEdgePlanePoint = thisTriWorldPosition[2];
                                intersectedEdgePlaneNormal = thisTriEdge20PlaneNormal;
                                minEdgePlaneIntersectionDistance = distToEdgePlane20;
                            }

                            if (minEdgePlaneIntersectionDistance < INF)
                            {
                                float projectionDist =
                                        IntersectRayPlaneDist(sampleWorldPosition,
                                                              -triNormalsMean,
                                                              nTriWorldPosition[0],
                                                              nTriNormal);
                                isInsideNeighborTriangleAfterProjected =
                                    (projectionDist >= -Epsilon);
                                if (isInsideNeighborTriangleAfterProjected)
                                {
                                    vec3 projectedSampleWorldPositionInNeighborTriPlane =
                                            sampleWorldPosition - triNormalsMean * projectionDist;

                                    isInsideNeighborTriangleAfterProjected =
                                        PointInTriangle(projectedSampleWorldPositionInNeighborTriPlane,
                                                        nTriWorldPosition[0],
                                                        nTriWorldPosition[1],
                                                        nTriWorldPosition[2]);

                                    sampleWorldPosition = projectedSampleWorldPositionInNeighborTriPlane;

                                    sampleBarycentricCoordsInNTri =
                                       GetBarycentricCoordinates(sampleWorldPosition,
                                                                 nTriWorldPosition[0],
                                                                 nTriWorldPosition[1],
                                                                 nTriWorldPosition[2]);
                                }
                            }
                        }

                        if (isInsideNeighborTriangleAfterProjected)
                        {
                            vec2[3] nTriUvs;
                            for (int j = 0; j < 3; ++j)
                            {
                                nTriUvs[j] = GetTriangleUvsElement(neighborTriId, j).xy;
                                nTriUvs[j].y = 1.0 - nTriUvs[j].y;
                            }

                            vec2 sampleUvsInNTri =
                                 sampleBarycentricCoordsInNTri[0] * nTriUvs[0] +
                                 sampleBarycentricCoordsInNTri[1] * nTriUvs[1] +
                                 sampleBarycentricCoordsInNTri[2] * nTriUvs[2];
                            totalWeight += weight;
                            sampleColor = texture(TextureToBlur, sampleUvsInNTri);
                            break;
                        }
                    }
                }
            }
            accumulatedColor += sampleColor * weight;
        }
    }
    // OutColor = vec4(0,0,0,1); return;

    float kernelSize = (BlurRadius * 2 + 1);
    vec4 meanColor = accumulatedColor;
    if (totalWeight > 0.0f)
    {
        meanColor /= totalWeight;
    }
    meanColor.a = 1.0f;
    OutColor = meanColor;
}


