#vertex

uniform mat4 SceneModelMatrix;

layout(location = 0) in vec3 vinTexturePosition;
layout(location = 1) in vec3 vinPosition;
layout(location = 2) in vec3 vinNormal;

out vec3 inWorldPosition;
out vec3 inWorldNormal;

void main()
{
    inWorldPosition = (SceneModelMatrix * vec4(vinPosition, 1)).xyz;
    inWorldNormal = (SceneModelMatrix * vec4(vinNormal, 0)).xyz;
    gl_Position = vec4(vinTexturePosition, 1);
}

// ===============================================================

#fragment
#define BANG_FRAGMENT

uniform mat4 SceneModelMatrix;
uniform int NumTriangles;
uniform sampler2D TrianglePositions;

uniform sampler2D GridTexture;
uniform int NumGridCells;
uniform vec3 GridCellSize;
uniform vec3 GridMinPoint;

in vec3 inWorldPosition;
in vec3 inWorldNormal;

layout(location = 0) out vec4 OutColor;

float IntersectRayPlaneDist(vec3 rayOrig, vec3 rayDir, vec3 planePoint, vec3 planeNormal)
{
    float dotProd = dot(planeNormal, rayDir);
    return dot(planePoint - rayOrig, planeNormal) / dotProd;
}
float IntersectRayTriangle(vec3 rayOrig, vec3 rayDir, vec3 triPoints[3])
{
    const float INF = 1e12;
    const float Epsilon = 1e-8;

    vec3 v10 = (triPoints[1] - triPoints[0]);
    vec3 v20 = (triPoints[2] - triPoints[0]);

    vec3 h = cross(rayDir, v20);
    float a = dot(v10, h);

    if (a > -Epsilon && a < Epsilon) { return INF; }

    float f = 1.0 / a;
    vec3 s = (rayOrig - triPoints[0]);
    float u = f * dot(s, h);
    if (u < 0.0 || u > 1.0) { return INF; }

    vec3 q = cross(s, v10);
    float v = f * dot(rayDir, q);
    if (v < 0.0 || u + v > 1.0) { return INF; }

    float t = (f * dot(v20, q));
    if (t < Epsilon) { return INF; }

    return t;
}

vec4 GetTextureData(sampler2D dataTexture, int index)
{
    vec2 textureSize = vec2(textureSize(dataTexture, 0));
    vec2 texelSize = (1.0 / textureSize);
    vec2 texCoord = vec2(mod(index, textureSize.x), index / textureSize.x);
    vec2 uvs = texCoord * texelSize;
    return texture(dataTexture, uvs, 0);
}

float dot2(vec3 x)
{
    return dot(x, x);
}
float rand(vec3 co)
{
    return fract(sin(dot(co.xyz, vec3(12.9898, 78.233, 32.123))) * 43758.5453);
}
vec3 rand3(vec3 co)
{
    return vec3(rand(co.xyz), rand(co.yxz), rand(co.zyx));
}

void main()
{
    vec3 worldPosition = inWorldPosition;
    vec3 worldNormal = normalize(inWorldNormal);

    float totalRays = 10;
    float maxDistance = 0.02;
    float intersectedRaysAO = 0;
    for (int iRay = 0; iRay < totalRays; ++iRay)
    {
        vec3 rayDirection = rand3(worldPosition * (iRay + 100)) + vec3(0.001);
        rayDirection = normalize(rayDirection * 2 - 1);
        rayDirection *= sign(dot(rayDirection, worldNormal));

        vec3 rayCurrentOrigin = worldPosition + worldNormal * 0.001f;
        vec3 rayDirectionSign = sign(rayDirection);

        vec3 gridWorldPos = (rayCurrentOrigin.xyz - GridMinPoint.xyz);
        vec3 gridCoordXYZ = floor(gridWorldPos.xyz / GridCellSize.xyz);

        bool insideGrid = true;
        float currentMaxDistance = maxDistance;
        while (insideGrid && currentMaxDistance > 0)
        {
            int NC = NumGridCells;
            int cellCoord = int(dot(vec3(NC * NC, NC, 1), gridCoordXYZ.zyx));
            // int cellCoord = int(NC * NC * gridCoordXYZ.z + NC * gridCoordXYZ.y + gridCoordXYZ.x);
            ivec2 cellTexCoordTriangleListBeginEnd = ivec2(GetTextureData(GridTexture, cellCoord).xy);

            bool foundIntersection = false;
            for (int texCoordi = cellTexCoordTriangleListBeginEnd[0];
                 texCoordi <= cellTexCoordTriangleListBeginEnd[1];
                 ++texCoordi)
            {
                vec2 gridTextureData = GetTextureData(GridTexture, texCoordi).xy;
                int triId = int(gridTextureData.r);
                vec3 triPoints[3];
                for (int vi = 0; vi < 3; ++vi)
                {
                    triPoints[vi] = GetTextureData(TrianglePositions, triId * 3 + vi).xyz;
                }

                float intersectionDist =
                    IntersectRayTriangle(rayCurrentOrigin, rayDirection, triPoints);
                if (intersectionDist < currentMaxDistance)
                {
                    float distFactor = (intersectionDist / currentMaxDistance);
                    intersectedRaysAO += (1.0f - distFactor) / totalRays;
                    foundIntersection = true;
                    break;
                }
            }
            if (foundIntersection) { break; }

            // Find which is the next grid cell we need to go to
            vec3 gridStepXYZ;
            vec3 cellMin = GridMinPoint + (gridCoordXYZ * GridCellSize);
            vec3 cellCenter = cellMin + GridCellSize * 0.5f;
            {
                vec3 planeXPoint = cellCenter + vec3(1,0,0) * 0.5f * GridCellSize.x * rayDirectionSign.x;
                float intDistPlaneX = IntersectRayPlaneDist(rayCurrentOrigin, rayDirection, planeXPoint, vec3(1,0,0));

                vec3 planeYPoint = cellCenter + vec3(0,1,0) * 0.5f * GridCellSize.y * rayDirectionSign.y;
                float intDistPlaneY = IntersectRayPlaneDist(rayCurrentOrigin, rayDirection, planeYPoint, vec3(0,1,0));

                vec3 planeZPoint = cellCenter + vec3(0,0,1) * 0.5f * GridCellSize.z * rayDirectionSign.z;
                float intDistPlaneZ = IntersectRayPlaneDist(rayCurrentOrigin, rayDirection, planeZPoint, vec3(0,0,1));

                float minIntersectionDist;
                if (intDistPlaneX <= intDistPlaneY && intDistPlaneX <= intDistPlaneZ)
                {
                    minIntersectionDist = intDistPlaneX;
                    gridStepXYZ = vec3(1,0,0) * rayDirectionSign.x;
                }
                else if (intDistPlaneY <= intDistPlaneX && intDistPlaneY <= intDistPlaneZ)
                {
                    minIntersectionDist = intDistPlaneY;
                    gridStepXYZ = vec3(0,1,0) * rayDirectionSign.y;
                }
                else
                {
                    minIntersectionDist = intDistPlaneZ;
                    gridStepXYZ = vec3(0,0,1) * rayDirectionSign.z;
                }

                currentMaxDistance -= minIntersectionDist;
                rayCurrentOrigin += rayDirection * minIntersectionDist;
            }

            // Advance in grid and update whether we are inside
            gridCoordXYZ += gridStepXYZ;
            insideGrid = (all(greaterThanEqual(gridCoordXYZ, vec3(0))) &&
                          all(lessThan(gridCoordXYZ, vec3(NumGridCells))));
        }
    }

    float ambientOcclusion = (intersectedRaysAO / (totalRays * maxDistance));
    OutColor = vec4(vec3(ambientOcclusion), 1);
}


