#vertex

uniform mat4 SceneModelMatrix;

layout(location = 0) in vec3 vinTexturePosition;
layout(location = 1) in vec3 vinPosition;
layout(location = 3) in vec2 vinUvs;

out vec3 inWorldPosition;
out vec2 inUv;
flat out int inTriId;

void main()
{
    inWorldPosition = (SceneModelMatrix * vec4(vinPosition, 1)).xyz;
    inUv = vinTexturePosition.xy * 0.5 + 0.5;
    inTriId = gl_VertexID / 3;
    gl_Position = vec4(vinTexturePosition, 1);
}

// ===============================================================

#fragment
#define BANG_FRAGMENT

#include "ArrayOfArrays.glsl"
#include "RayCast.glsl"

ARRAY_OF_ARRAYS(TriangleUvs)
ARRAY_OF_ARRAYS(TriangleNeighborhoods)

vec3[3] GetTrianglePoints(int triId)
{
    vec3 triPoints[3];
    for (int vi = 0; vi < 3; ++vi)
    {
        triPoints[vi] = GetTrianglePositionsElement(triId, vi).xyz;
    }
    return triPoints;
}

uniform sampler2D TextureToBlur;
uniform float BlurRadius;
uniform float BlurStep;

in vec3 inWorldPosition;
in vec2 inUv;
flat in int inTriId;

layout(location = 0) out vec4 OutColor;

void main()
{
    vec3 thisWorldPosition = inWorldPosition;
    int thisTriId = inTriId;
    vec2 thisUv = inUv;

    vec3[3] thisTriWorldPosition = GetTrianglePoints(thisTriId);
    vec3 thisTriXVector = normalize(thisTriWorldPosition[1] - thisTriWorldPosition[0]);
    vec3 thisTriNormal = normalize(
                cross(thisTriXVector, thisTriWorldPosition[2] - thisTriWorldPosition[0]));
    vec3 thisTriYVector = normalize(cross(thisTriXVector, thisTriNormal));

    vec4 accumulatedColor = vec4(0);
    float totalWeight = 0.0f;
    float BR = BlurRadius;
    for (float y = -BR; y <= BR; ++y)
    {
        for (float x = -BR; x <= BR; ++x)
        {
            vec2 xy = vec2(x,y);
            float offsetXYLength = length(xy);
            if (offsetXYLength > BlurRadius)
            {
                continue;
            }

            vec2 sampleXYOffset = xy * BlurStep;
            vec3 sampleWorldOffset = (thisTriXVector * sampleXYOffset.x) +
                                     (thisTriYVector * sampleXYOffset.y);
            vec3 sampleWorldPosition = thisWorldPosition + sampleWorldOffset;

            bool alreadyHit = false;
            const int SpherePointsPerAxis = 10;
            const float SpherePointsAngleStepPerAxis = (1.0f / SpherePointsPerAxis);
            vec3 rayOrigin = sampleWorldPosition + thisTriNormal * 0.0001f;
            for (int i = 0; i < SpherePointsPerAxis; ++i)
            {
                float angleI = PI2 * i * SpherePointsAngleStepPerAxis;
                for (int j = 0; j < SpherePointsPerAxis; ++j)
                {
                    float angleJ = PI2 * j * SpherePointsAngleStepPerAxis;
                    vec3 rayDirection = normalize(vec3(sin(angleI) * cos(angleJ),
                                                       sin(angleI) * sin(angleJ),
                                                       cos(angleI)));
                    const float maxDistance = 0.5f;

                    int hitTriId;
                    float hitDistance;
                    vec3 triBaryCoords;
                    if (RayCast(rayOrigin, rayDirection,
                                maxDistance, hitDistance,
                                hitTriId, triBaryCoords))
                    {
                        vec2[3] hitTriUvs;
                        for (int j = 0; j < 3; ++j)
                        {
                            hitTriUvs[j] = GetTriangleUvsElement(hitTriId, j).xy;
                        }

                        vec3[3] hitTriWorldPositions = GetTrianglePoints(hitTriId);

                        vec3 hitWorldPosition = rayOrigin + rayDirection * hitDistance;
                        vec3 sampleBarycentricCoordsInHitTri =
                           GetBarycentricCoordinates(hitWorldPosition,
                                                     hitTriWorldPositions);
                        vec2 sampleUvsInHitTri =
                             sampleBarycentricCoordsInHitTri[0] * hitTriUvs[0] +
                             sampleBarycentricCoordsInHitTri[1] * hitTriUvs[1] +
                             sampleBarycentricCoordsInHitTri[2] * hitTriUvs[2];
                        sampleUvsInHitTri.y = 1.0 - sampleUvsInHitTri.y;

                        vec4 sampleColor = texture(TextureToBlur, sampleUvsInHitTri);

                        float sampleWorldOffsetLength = length(sampleWorldOffset);
                        float weight = 1.0f; // exp(-sampleWorldOffsetLength * 1.0);
                        totalWeight += weight;
                        accumulatedColor += weight * sampleColor;
                        alreadyHit = true;
                        // break;
                    }
                }

                if (alreadyHit)
                {
                    // break;
                }
            }
        }
    }

    vec4 meanColor = accumulatedColor;
    if (totalWeight > 0.0f)
    {
        meanColor /= totalWeight;
    }
    OutColor = meanColor;
}


