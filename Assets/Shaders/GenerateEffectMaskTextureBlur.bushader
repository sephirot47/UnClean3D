#vertex

uniform mat4 SceneModelMatrix;

layout(location = 0) in vec3 vinTexturePosition;
layout(location = 1) in vec3 vinPosition;
layout(location = 3) in vec2 vinUvs;

out vec3 inWorldPosition;
out vec2 inUv;
flat out int inTriId;

void main()
{
    inWorldPosition = (SceneModelMatrix * vec4(vinPosition, 1)).xyz;
    inUv = vinTexturePosition.xy * 0.5 + 0.5;
    inTriId = gl_VertexID / 3;
    gl_Position = vec4(vinTexturePosition, 1);
}

// ===============================================================

#fragment
#define BANG_FRAGMENT

#include "ArrayOfArrays.glsl"

ARRAY_OF_ARRAYS(TriangleUvs)
ARRAY_OF_ARRAYS(TrianglePositions)
ARRAY_OF_ARRAYS(OneRingNeighborhoods)

uniform sampler2D TextureToBlur;
uniform float BlurRadius;
uniform float BlurStep;

const float Epsilon = 1e-4f;
const float INF = 1e9f;

float side(vec2 p1, vec2 p2, vec2 p3)
{
    return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);
}

vec3 GetProjectedPoint(vec3 point, vec3 planePoint, vec3 planeNormal)
{
    float dist = dot(point - planePoint, planeNormal);
    return point - (planeNormal * dist);
}

float GetTriangleArea(vec2 p0, vec2 p1, vec2 p2)
{
    return abs(p0.x * (p1.y - p2.y) + p1.x * (p2.y - p0.y) + p2.x * (p0.y - p1.y)) * 0.5f;
}
float GetTriangleArea(vec3 p0, vec3 p1, vec3 p2)
{
    return length(cross((p1 - p0), (p2 - p0))) * 0.5f;
}

vec3 GetBarycentricCoordinates(vec3 point, vec3 triP0, vec3 triP1, vec3 triP2)
{
    vec3 v0 = triP1 - triP0;
    vec3 v1 = triP2 - triP0;
    vec3 triNormal = normalize(cross(v0, v1));
    vec3 projPoint = GetProjectedPoint(point, triP0, triNormal);

    vec3 v2 = projPoint - triP0;
    float d00 = dot(v0, v0);
    float d01 = dot(v0, v1);
    float d11 = dot(v1, v1);
    float d20 = dot(v2, v0);
    float d21 = dot(v2, v1);
    float denom = d00 * d11 - d01 * d01;

    vec3 baryCoords;
    baryCoords.y = (d11 * d20 - d01 * d21) / denom;
    baryCoords.z = (d00 * d21 - d01 * d20) / denom;
    baryCoords.x = 1.0f - baryCoords.y - baryCoords.z;
    return baryCoords;
}

vec3 GetBarycentricCoordinates(vec3 point, vec3[3] trianglePoints)
{
    return GetBarycentricCoordinates(point, trianglePoints[0],
                                     trianglePoints[1], trianglePoints[2]);
}

bool PointInTriangle(vec3 baryCoords)
{
    return (baryCoords[0] >= -Epsilon && baryCoords[0] <= 1.0f + Epsilon &&
            baryCoords[1] >= -Epsilon && baryCoords[1] <= 1.0f + Epsilon &&
            baryCoords[2] >= -Epsilon && baryCoords[2] <= 1.0f + Epsilon);
}

bool PointInTriangle(vec3 point, vec3 triP0, vec3 triP1, vec3 triP2)
{
    vec3 baryCoords = GetBarycentricCoordinates(point, triP0, triP1, triP2);
    return PointInTriangle(baryCoords);
}

bool PointInTriangle(vec3 point, vec3[3] trianglePoints)
{
    vec3 baryCoords = GetBarycentricCoordinates(point, trianglePoints[0],
                                                trianglePoints[1],
                                                trianglePoints[2]);
    return PointInTriangle(baryCoords);
}

float IntersectRayPlaneDist(vec3 rayOrig, vec3 rayDir, vec3 planePoint, vec3 planeNormal)
{
    float dotProd = dot(planeNormal, rayDir);
    return dot(planePoint - rayOrig, planeNormal) / dotProd;
}

vec3[3] GetTrianglePoints(int triId)
{
    vec3 triPoints[3];
    for (int vi = 0; vi < 3; ++vi)
    {
        triPoints[vi] = GetTrianglePositionsElement(triId, vi).xyz;
    }
    return triPoints;
}

in vec3 inWorldPosition;
in vec2 inUv;
flat in int inTriId;

layout(location = 0) out vec4 OutColor;

void main()
{
    vec3 thisWorldPosition = inWorldPosition;
    int thisTriId = inTriId;
    vec2 thisUv = inUv;

    vec3[3] thisTriWorldPosition = GetTrianglePoints(thisTriId);
    vec3 thisTriXVector = normalize(thisTriWorldPosition[1] - thisTriWorldPosition[0]);
    vec3 thisTriNormal = normalize(
                cross(thisTriXVector, thisTriWorldPosition[2] - thisTriWorldPosition[0]));
    vec3 thisTriYVector = normalize(cross(thisTriXVector, thisTriNormal));

    vec4 accumulatedColor = vec4(0);
    float totalWeight = 0.0f;
    int numNeighbors = GetOneRingNeighborhoodsArraySize(thisTriId);
    for (float y = -BlurRadius; y <= BlurRadius; ++y)
    {
        for (float x = -BlurRadius; x <= BlurRadius; ++x)
        {
            bool insideSomeTriangle = true;
            vec2 xy = vec2(x,y);
            float offsetXYLength = length(xy);
            if (offsetXYLength >= BlurRadius)
            {
                continue;
            }

            vec2 sampleXYOffset = xy * BlurStep;
            vec3 sampleWorldOffset = thisTriXVector * sampleXYOffset.x +
                                     thisTriYVector * sampleXYOffset.y;
            vec3 sampleWorldPosition = thisWorldPosition + sampleWorldOffset;
            float sampleWorldOffsetLength = length(sampleWorldOffset);

            vec4 sampleColor = vec4(0);
            {
                for (int i = 0; i < (numNeighbors + 1); ++i) // Neighbors or this triId
                {
                    int neighborTriId = (i == 0 ? thisTriId :
                          int(GetOneRingNeighborhoodsElement(thisTriId, i-1).x));

                    vec3[3] nTriWorldPosition = GetTrianglePoints(neighborTriId);
                    vec3 sampleBarycentricCoordsInNTri =
                       GetBarycentricCoordinates(sampleWorldPosition, nTriWorldPosition);

                    // Modify sample world position so that it follows the surface
                    vec3 nTriEdge01 = (nTriWorldPosition[1] - nTriWorldPosition[0]);
                    vec3 nTriEdge02 = (nTriWorldPosition[2] - nTriWorldPosition[0]);
                    vec3 nTriNormal = normalize(cross(nTriEdge01, nTriEdge02));

                    bool isInsideNeighborTriangleAfterProjected = true;
                    if (neighborTriId != thisTriId)
                    {
                        vec3 triNormalsMean = normalize(thisTriNormal + nTriNormal);
                        vec3 sampleWorldOffsetDir = (sampleWorldOffset / sampleWorldOffsetLength);

                        isInsideNeighborTriangleAfterProjected = false;
                        for (int j = 0; j < 3; ++j)
                        {

                            vec3 thisTriEdge = (thisTriWorldPosition[(j+1)%3] - thisTriWorldPosition[j]);
                            vec3 thisTriEdgeNorm = normalize(thisTriEdge);

                            vec3 thisTriEdgePlaneNormal = normalize( cross(thisTriEdgeNorm, triNormalsMean) );

                            float distToEdgePlane =
                                IntersectRayPlaneDist(thisWorldPosition, sampleWorldOffsetDir,
                                                      thisTriWorldPosition[0], thisTriEdgePlaneNormal);

                            if (distToEdgePlane < INF)
                            {
                                vec3 projectionRayDir = -triNormalsMean;
                                float projectionDist =
                                    IntersectRayPlaneDist(sampleWorldPosition,
                                                          projectionRayDir,
                                                          nTriWorldPosition[0],
                                                          nTriNormal);
                                isInsideNeighborTriangleAfterProjected =
                                    (projectionDist >= -Epsilon);
                                if (isInsideNeighborTriangleAfterProjected)
                                {
                                    vec3 projectedSampleWorldPositionInNeighborTriPlane =
                                            sampleWorldPosition + projectionRayDir * projectionDist;

                                    sampleWorldPosition = projectedSampleWorldPositionInNeighborTriPlane;

                                    sampleBarycentricCoordsInNTri =
                                       GetBarycentricCoordinates(sampleWorldPosition,
                                                                 nTriWorldPosition);

                                    isInsideNeighborTriangleAfterProjected =
                                        PointInTriangle(sampleBarycentricCoordsInNTri);

                                    break;
                                }
                            }
                        }
                    }

                    if (isInsideNeighborTriangleAfterProjected)
                    {
                        vec2[3] nTriUvs;
                        for (int j = 0; j < 3; ++j)
                        {
                            nTriUvs[j] = GetTriangleUvsElement(neighborTriId, j).xy;
                        }

                        vec2 sampleUvsInNTri =
                             sampleBarycentricCoordsInNTri[0] * nTriUvs[0] +
                             sampleBarycentricCoordsInNTri[1] * nTriUvs[1] +
                             sampleBarycentricCoordsInNTri[2] * nTriUvs[2];
                        sampleUvsInNTri.y = 1.0 - sampleUvsInNTri.y;

                        vec4 sampleColor = texture(TextureToBlur, sampleUvsInNTri);
                        float weight = exp(-sampleWorldOffsetLength * 1.0);
                        totalWeight += weight;
                        accumulatedColor += weight * sampleColor;
                    }
                }
            }
        }
    }

    vec4 meanColor = accumulatedColor;
    if (totalWeight > 0.0f)
    {
        meanColor /= totalWeight;
    }
    OutColor = meanColor;
}


